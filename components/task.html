<div id="task-template">
  <div class="task-item {{classes}}" id="task-{{id}}">
    <div>
      <div style="display: inline-flex">
        <i class="material-icons task-btn-swap" title="{{swap_text}}">{{ icon.swap }}</i>
        <span class="task-content" style="cursor: pointer">{{ name }}</span>
      </div>
      <span style="float: right">
        <button class="task-btn-color-label" style="background-color: {{color}}" title="Change Color">
          <i class="material-icons task-btn-color" title="Change Color">{{ icon.color }}</i>
          <input class="task-btn-color-picker" type="color" value="{{color}}">
        </button>
        <i class="material-icons task-btn-edit" title="Edit">{{ icon.edit }}</i>
        <i class="material-icons task-btn-delete" title="Delete">{{ icon.delete }}</i>
      </span>
    </div>
    <div>{{{ html_description }}}</div>
  </div>
</div>

<script>

function contrasting_color(el) {
  /*
    * The following is used to calculate whether the letters should be in white or black, it follows the W3C guidelines
    * See: https://www.w3.org/TR/WCAG20/
    * See also: https://stackoverflow.com/questions/3942878/how-to-decide-font-color-in-white-or-black-depending-on-background-color
  */
  let color = getComputedStyle(el).backgroundColor;
  let colors = color.substr(4)
  colors = colors.substr(0, colors.length - 1).split(',').map(o => Number(o.trim()) / 255).slice(0, 3)
  const c = colors.map((col) => {
      if (col <= 0.03928) {
          return col / 12.92;
      }
      return Math.pow((col + 0.055) / 1.055, 2.4);
  });
  const text_color = (0.2126 * c[0]) + (0.7152 * c[1]) + (0.0722 * c[2]) > 0.179 ? 'black' : 'white';
  console.log(colors);
  console.log((0.2126 * c[0]) + (0.7152 * c[1]) + (0.0722 * c[2]));
  console.log(text_color);
  return text_color;
}

let indexes = 0;
var Tasks = {};
class Task {
  constructor(cfg={}) {
    this.data = Object.assign({
      id: false,
      day: 'today',
      name: 'default name',
      description: '',
      //subtasks: [],
      color: false,
      completed: false,
      color: '#ffffff',
    }, cfg);
    if (this.data.id == false) {
      this.data.id = ++indexes;
    }
    for (let key of Object.keys(this.data)) {
      Object.defineProperty(this, key, {
        get() {
          return this.data[key];
        },
        set(value) {
          this.data[key] = value;
          TaskList.update(this);
        }
      })
    }
    Tasks[this.data.id] = this;
  }
  render() {
    return Mustache.render(document.querySelector('#task-template').innerHTML, {
      ...this.data,
      classes: this.classes,
      icon: this.icons,
      html_description: marked(this.data.description || ''),
      swap_text: this.day == 'today' ? 'Move to Tomorrow' : 'Move to Today',
    });
  }
  hook($el) {
    let task = this;
    $el.on('click', function({ target }) {
      if (target.classList.contains('task-btn-swap')) {
        task.swap()
      } else if (target.classList.contains('task-btn-color-label') || target.classList.contains('task-btn-color')) {
        $el[0].querySelector('input[type="color"]').click();
      } else if (target.tagName != 'A' && target.tagName != 'INPUT') {
        console.log(target)
        task.completed = !task.completed;
      }
    })
    let color_label = $el[0].querySelector('.task-btn-color-label');
    color_label.firstElementChild.style.color = contrasting_color(color_label);
    $el.find('input[type="color"]').on('change', function({ target }) {
      task.color = target.value;
    }).on('input', function({ target }) {
      color_label.style.backgroundColor = target.value;
      color_label.firstElementChild.style.color = contrasting_color(color_label);
    })
    let icons = task.icons;
    let hoverIcon = function(name) {
      let normal = icons[name];
      let hover = icons[name + '_hover'];
      $el.find(`.task-btn-${name}`).hover(function() {
        this.innerHTML = hover;
      }, function() {
        this.innerHTML = normal
      })
    }
    hoverIcon('edit');
    hoverIcon('swap');
    hoverIcon('delete');
    //$el.find('.task-btn-color')
  }
  get classes() {
    let classes = {
      'task-completed': this.completed,
    };
    return Object.entries(classes).filter(o => o[1]).map(o => o[0]).join(' ');
  }
  get icons() {
    return {
      swap: 'arrow_' + (this.day == 'today' ? 'forward' : 'back'),
      swap_hover: (this.day == 'today' ? 'east' : 'west'),
      edit: 'edit',
      edit_hover: 'drive_file_rename_outline',
      delete: 'delete',
      delete_hover: 'delete_forever',
      color: "format_color_fill",
    }
  }
  swap() {
    if (this.day == 'today') {
      this.day = 'tomorrow';
    } else {
      this.day = 'today';
    }
  }

}
</script>

<style lang="scss">
  .task-item {
    margin-bottom: 5px;
    &.task-completed .task-content {
      text-decoration: line-through;
    }
    .material-icons {
      cursor: pointer;
      display: inline-block;
    }
    input[type="color"] {
      border: none;
      background: none;
      width: 0px;
      opacity: 0;
      height: 0px;
      padding: 0px;
      float: left;
    }
    .task-btn-color-label {
      border: none;
      width: 100px;
      margin-right: 25px;
      padding: 0px;
      border-radius: 0.5em;
      cursor: pointer;
      &:hover {
        .task-btn-color {
          opacity: 1;
        }
      }
      .task-btn-color {
        transform: scale(0.75);
        transition: opacity 0.15s;
        opacity: 0;
        color: white;
        &.light {
          color: black;
        }
      }
    }
    .task-btn-swap {
      padding-right: 20px;
    }
    .task-btn-swap, .task-btn-delete, .task-btn-edit {
      transition: transform 0.15s;
      transform: scale(0.85);
      &:hover {
        transform: scale(1);
      }
    }
    //background-color: red;
    &:hover {
      //background-color: blue;
    }
  }
</style>
